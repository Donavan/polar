<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.bundle.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <link rel="stylesheet" href="polar.css">
</head>
<body>
<div class="container">
  <!-- Render the overall chart -->
  <div class="row overall">
    <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Overall</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartOverall" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayOverall" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendOverall" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksOverall" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

  </div>
  
    
    <!-- Render the Automation category chart -->
    <div class="row category_row">
    <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Automation</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartAutomation" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayAutomation" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendAutomation" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksAutomation" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

    </div>
    
      
      <!-- Render the Automation - Version Control subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Automation - Version Control</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartAutomationVersionControl" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayAutomationVersionControl" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendAutomationVersionControl" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksAutomationVersionControl" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      <!-- Render the Automation - Environment subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Automation - Environment</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartAutomationEnvironment" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayAutomationEnvironment" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendAutomationEnvironment" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksAutomationEnvironment" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      <!-- Render the Automation - Security/Audit subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Automation - Security/Audit</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartAutomationSecurityAudit" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayAutomationSecurityAudit" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendAutomationSecurityAudit" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksAutomationSecurityAudit" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      
      
      
      
      
      
  
    
    <!-- Render the Testing category chart -->
    <div class="row category_row">
    <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Testing</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartTesting" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayTesting" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendTesting" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksTesting" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

    </div>
    
      
      <!-- Render the Testing - Version Control subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Testing - Version Control</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartTestingVersionControl" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayTestingVersionControl" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendTestingVersionControl" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksTestingVersionControl" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      <!-- Render the Testing - Environment subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Testing - Environment</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartTestingEnvironment" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayTestingEnvironment" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendTestingEnvironment" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksTestingEnvironment" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      <!-- Render the Testing - Security/Audit subcategory -->
      <div class="row sub_category_row">
      <div class='row'>
  <div class='col-lg-12'>
    <div class="container">
      <div class="row">
        <h2>Testing - Security/Audit</h2>
      </div>
      <div class="row">
        <div class='chart'>
          <canvas id="myChartTestingSecurityAudit" width="800" height="500" class='content'></canvas>
        </div>
        <div class='overlay'>
          <canvas id="myOverlayTestingSecurityAudit" width="800" height="500"></canvas>
        </div>
        <div class='legend'>
          <canvas id="legendTestingSecurityAudit" width="800" height="500"></canvas>
        </div>
        <div class='ticks'>
          <canvas id="myTicksTestingSecurityAudit" width="800" height="500"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    
      
      
      
      
      
      
      
  
</div>
<!-- <script> -->
<!--     // Scripts for the overall chart -->
    <script>
    var ctxOverall = document.getElementById("myChartOverall").getContext("2d");
    var overlayCtxOverall = document.getElementById("myOverlayOverall").getContext("2d");
    var ticksCtxOverall = document.getElementById("myTicksOverall").getContext("2d");
    var legendCtxOverall = document.getElementById("legendOverall").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataOverall = {
        datasets: [
            {
                label: "Score",
                data: [1.9444444444444446,2.388888888888889],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Automation","Testing"],
        true_values: [1.9444444444444446,2.388888888888889]
    };
    optionsOverall = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataOverall = {
        datasets: [
            {
                label: "Score",
                data: [0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Automation","Testing"],
        true_values: [1.9444444444444446,2.388888888888889]
    };
    legendOptionsOverall = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataOverall = {
        datasets: [
            {
                label: "Score",
                data: [5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Automation","Testing"],
        true_values: [1.9444444444444446,2.388888888888889]
    };
    overlayOptionsOverall = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataOverall = {
        datasets: [
            {
                label: "Score",
                data: [0,0],
            }
        ],
        labels: ["Automation","Testing"],
        true_values: [1.9444444444444446,2.388888888888889]
    };
    ticksOptionsOverall = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxOverall, {
        data: dataOverall,
        type: "polarArea",
        options: optionsOverall
    });

    new Chart(overlayCtxOverall, {
        data: overlayDataOverall,
        type: "polarArea",
        options: overlayOptionsOverall
    });

    new Chart(ticksCtxOverall, {
        data: ticksDataOverall,
        type: "polarArea",
        options: ticksOptionsOverall
    });

    new Chart(legendCtxOverall, {
        data: legendDataOverall,
        type: "polarArea",
        options: legendOptionsOverall
    });

</script>
    
    
    <!-- Scripts for the Automation category chart -->
    <script>
    var ctxAutomation = document.getElementById("myChartAutomation").getContext("2d");
    var overlayCtxAutomation = document.getElementById("myOverlayAutomation").getContext("2d");
    var ticksCtxAutomation = document.getElementById("myTicksAutomation").getContext("2d");
    var legendCtxAutomation = document.getElementById("legendAutomation").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataAutomation = {
        datasets: [
            {
                label: "Score",
                data: [2.1666666666666665,1.6666666666666667,2.0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [2.1666666666666665,1.6666666666666667,2.0]
    };
    optionsAutomation = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataAutomation = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [2.1666666666666665,1.6666666666666667,2.0]
    };
    legendOptionsAutomation = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataAutomation = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [2.1666666666666665,1.6666666666666667,2.0]
    };
    overlayOptionsAutomation = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataAutomation = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [2.1666666666666665,1.6666666666666667,2.0]
    };
    ticksOptionsAutomation = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxAutomation, {
        data: dataAutomation,
        type: "polarArea",
        options: optionsAutomation
    });

    new Chart(overlayCtxAutomation, {
        data: overlayDataAutomation,
        type: "polarArea",
        options: overlayOptionsAutomation
    });

    new Chart(ticksCtxAutomation, {
        data: ticksDataAutomation,
        type: "polarArea",
        options: ticksOptionsAutomation
    });

    new Chart(legendCtxAutomation, {
        data: legendDataAutomation,
        type: "polarArea",
        options: legendOptionsAutomation
    });

</script>
    
    
    <!-- Scripts for the Automation - Version Control subcategory -->
    <script>
    var ctxAutomationVersionControl = document.getElementById("myChartAutomationVersionControl").getContext("2d");
    var overlayCtxAutomationVersionControl = document.getElementById("myOverlayAutomationVersionControl").getContext("2d");
    var ticksCtxAutomationVersionControl = document.getElementById("myTicksAutomationVersionControl").getContext("2d");
    var legendCtxAutomationVersionControl = document.getElementById("legendAutomationVersionControl").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataAutomationVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [1,3,2,2,4,1],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,3,2,2,4,1]
    };
    optionsAutomationVersionControl = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataAutomationVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,3,2,2,4,1]
    };
    legendOptionsAutomationVersionControl = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataAutomationVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5,5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,3,2,2,4,1]
    };
    overlayOptionsAutomationVersionControl = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataAutomationVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0],
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,3,2,2,4,1]
    };
    ticksOptionsAutomationVersionControl = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxAutomationVersionControl, {
        data: dataAutomationVersionControl,
        type: "polarArea",
        options: optionsAutomationVersionControl
    });

    new Chart(overlayCtxAutomationVersionControl, {
        data: overlayDataAutomationVersionControl,
        type: "polarArea",
        options: overlayOptionsAutomationVersionControl
    });

    new Chart(ticksCtxAutomationVersionControl, {
        data: ticksDataAutomationVersionControl,
        type: "polarArea",
        options: ticksOptionsAutomationVersionControl
    });

    new Chart(legendCtxAutomationVersionControl, {
        data: legendDataAutomationVersionControl,
        type: "polarArea",
        options: legendOptionsAutomationVersionControl
    });

</script>
    
    
    <!-- Scripts for the Automation - Environment subcategory -->
    <script>
    var ctxAutomationEnvironment = document.getElementById("myChartAutomationEnvironment").getContext("2d");
    var overlayCtxAutomationEnvironment = document.getElementById("myOverlayAutomationEnvironment").getContext("2d");
    var ticksCtxAutomationEnvironment = document.getElementById("myTicksAutomationEnvironment").getContext("2d");
    var legendCtxAutomationEnvironment = document.getElementById("legendAutomationEnvironment").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataAutomationEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [3,2,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [3,2,0]
    };
    optionsAutomationEnvironment = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataAutomationEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [3,2,0]
    };
    legendOptionsAutomationEnvironment = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataAutomationEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [3,2,0]
    };
    overlayOptionsAutomationEnvironment = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataAutomationEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [3,2,0]
    };
    ticksOptionsAutomationEnvironment = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxAutomationEnvironment, {
        data: dataAutomationEnvironment,
        type: "polarArea",
        options: optionsAutomationEnvironment
    });

    new Chart(overlayCtxAutomationEnvironment, {
        data: overlayDataAutomationEnvironment,
        type: "polarArea",
        options: overlayOptionsAutomationEnvironment
    });

    new Chart(ticksCtxAutomationEnvironment, {
        data: ticksDataAutomationEnvironment,
        type: "polarArea",
        options: ticksOptionsAutomationEnvironment
    });

    new Chart(legendCtxAutomationEnvironment, {
        data: legendDataAutomationEnvironment,
        type: "polarArea",
        options: legendOptionsAutomationEnvironment
    });

</script>
    
    
    <!-- Scripts for the Automation - Security/Audit subcategory -->
    <script>
    var ctxAutomationSecurityAudit = document.getElementById("myChartAutomationSecurityAudit").getContext("2d");
    var overlayCtxAutomationSecurityAudit = document.getElementById("myOverlayAutomationSecurityAudit").getContext("2d");
    var ticksCtxAutomationSecurityAudit = document.getElementById("myTicksAutomationSecurityAudit").getContext("2d");
    var legendCtxAutomationSecurityAudit = document.getElementById("legendAutomationSecurityAudit").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataAutomationSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [2,2,1,3,1,3,3,1],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [2,2,1,3,1,3,3,1]
    };
    optionsAutomationSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataAutomationSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [2,2,1,3,1,3,3,1]
    };
    legendOptionsAutomationSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataAutomationSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5,5,5,5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [2,2,1,3,1,3,3,1]
    };
    overlayOptionsAutomationSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataAutomationSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0,0,0],
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [2,2,1,3,1,3,3,1]
    };
    ticksOptionsAutomationSecurityAudit = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxAutomationSecurityAudit, {
        data: dataAutomationSecurityAudit,
        type: "polarArea",
        options: optionsAutomationSecurityAudit
    });

    new Chart(overlayCtxAutomationSecurityAudit, {
        data: overlayDataAutomationSecurityAudit,
        type: "polarArea",
        options: overlayOptionsAutomationSecurityAudit
    });

    new Chart(ticksCtxAutomationSecurityAudit, {
        data: ticksDataAutomationSecurityAudit,
        type: "polarArea",
        options: ticksOptionsAutomationSecurityAudit
    });

    new Chart(legendCtxAutomationSecurityAudit, {
        data: legendDataAutomationSecurityAudit,
        type: "polarArea",
        options: legendOptionsAutomationSecurityAudit
    });

</script>
    
    
    
    
    
    
    
    
    
    
    <!-- Scripts for the Testing category chart -->
    <script>
    var ctxTesting = document.getElementById("myChartTesting").getContext("2d");
    var overlayCtxTesting = document.getElementById("myOverlayTesting").getContext("2d");
    var ticksCtxTesting = document.getElementById("myTicksTesting").getContext("2d");
    var legendCtxTesting = document.getElementById("legendTesting").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataTesting = {
        datasets: [
            {
                label: "Score",
                data: [1.6666666666666667,3.0,2.5],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [1.6666666666666667,3.0,2.5]
    };
    optionsTesting = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataTesting = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [1.6666666666666667,3.0,2.5]
    };
    legendOptionsTesting = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataTesting = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [1.6666666666666667,3.0,2.5]
    };
    overlayOptionsTesting = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataTesting = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
            }
        ],
        labels: ["Version Control","Environment","Security/Audit"],
        true_values: [1.6666666666666667,3.0,2.5]
    };
    ticksOptionsTesting = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxTesting, {
        data: dataTesting,
        type: "polarArea",
        options: optionsTesting
    });

    new Chart(overlayCtxTesting, {
        data: overlayDataTesting,
        type: "polarArea",
        options: overlayOptionsTesting
    });

    new Chart(ticksCtxTesting, {
        data: ticksDataTesting,
        type: "polarArea",
        options: ticksOptionsTesting
    });

    new Chart(legendCtxTesting, {
        data: legendDataTesting,
        type: "polarArea",
        options: legendOptionsTesting
    });

</script>
    
    
    <!-- Scripts for the Testing - Version Control subcategory -->
    <script>
    var ctxTestingVersionControl = document.getElementById("myChartTestingVersionControl").getContext("2d");
    var overlayCtxTestingVersionControl = document.getElementById("myOverlayTestingVersionControl").getContext("2d");
    var ticksCtxTestingVersionControl = document.getElementById("myTicksTestingVersionControl").getContext("2d");
    var legendCtxTestingVersionControl = document.getElementById("legendTestingVersionControl").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataTestingVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [1,1,1,2,4,1],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,1,1,2,4,1]
    };
    optionsTestingVersionControl = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataTestingVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,1,1,2,4,1]
    };
    legendOptionsTestingVersionControl = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataTestingVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5,5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,1,1,2,4,1]
    };
    overlayOptionsTestingVersionControl = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataTestingVersionControl = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0],
            }
        ],
        labels: ["Enforced Pre-commit validations","Feature Based Change Sets","Commit rollback on CI Failure","Branching/Merging Strategy","Integrated with Defect Management System","Integrated with Story Management System"],
        true_values: [1,1,1,2,4,1]
    };
    ticksOptionsTestingVersionControl = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxTestingVersionControl, {
        data: dataTestingVersionControl,
        type: "polarArea",
        options: optionsTestingVersionControl
    });

    new Chart(overlayCtxTestingVersionControl, {
        data: overlayDataTestingVersionControl,
        type: "polarArea",
        options: overlayOptionsTestingVersionControl
    });

    new Chart(ticksCtxTestingVersionControl, {
        data: ticksDataTestingVersionControl,
        type: "polarArea",
        options: ticksOptionsTestingVersionControl
    });

    new Chart(legendCtxTestingVersionControl, {
        data: legendDataTestingVersionControl,
        type: "polarArea",
        options: legendOptionsTestingVersionControl
    });

</script>
    
    
    <!-- Scripts for the Testing - Environment subcategory -->
    <script>
    var ctxTestingEnvironment = document.getElementById("myChartTestingEnvironment").getContext("2d");
    var overlayCtxTestingEnvironment = document.getElementById("myOverlayTestingEnvironment").getContext("2d");
    var ticksCtxTestingEnvironment = document.getElementById("myTicksTestingEnvironment").getContext("2d");
    var legendCtxTestingEnvironment = document.getElementById("legendTestingEnvironment").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataTestingEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [2,3,4],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [2,3,4]
    };
    optionsTestingEnvironment = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataTestingEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [2,3,4]
    };
    legendOptionsTestingEnvironment = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataTestingEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [2,3,4]
    };
    overlayOptionsTestingEnvironment = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataTestingEnvironment = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0],
            }
        ],
        labels: ["Provisioning Self-service tear up/down [individual developer]","Provisioning Infrastructure as Code - Templated provisioning","Provisioning Containers and Orchestration"],
        true_values: [2,3,4]
    };
    ticksOptionsTestingEnvironment = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxTestingEnvironment, {
        data: dataTestingEnvironment,
        type: "polarArea",
        options: optionsTestingEnvironment
    });

    new Chart(overlayCtxTestingEnvironment, {
        data: overlayDataTestingEnvironment,
        type: "polarArea",
        options: overlayOptionsTestingEnvironment
    });

    new Chart(ticksCtxTestingEnvironment, {
        data: ticksDataTestingEnvironment,
        type: "polarArea",
        options: ticksOptionsTestingEnvironment
    });

    new Chart(legendCtxTestingEnvironment, {
        data: legendDataTestingEnvironment,
        type: "polarArea",
        options: legendOptionsTestingEnvironment
    });

</script>
    
    
    <!-- Scripts for the Testing - Security/Audit subcategory -->
    <script>
    var ctxTestingSecurityAudit = document.getElementById("myChartTestingSecurityAudit").getContext("2d");
    var overlayCtxTestingSecurityAudit = document.getElementById("myOverlayTestingSecurityAudit").getContext("2d");
    var ticksCtxTestingSecurityAudit = document.getElementById("myTicksTestingSecurityAudit").getContext("2d");
    var legendCtxTestingSecurityAudit = document.getElementById("legendTestingSecurityAudit").getContext("2d");

    // This is the actual data being plotted.
    // The only relevant bits are the background colors and the data values
    dataTestingSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [3,2,1,3,1,3,3,4],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["#000000", "#000000", "#000000", "#000000", "#000000",
                    "#000000", "#000000", "#000000", "#000000"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [3,2,1,3,1,3,3,4]
    };
    optionsTestingSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This layer provides the legend
    legendDataTestingSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0,0,0],
                backgroundColor: ["#59B9EF","#B5D855","#FBC363","#81D8FD","#DE94D4","#F5D048","#90B9D1","#CDC5A5","#50BBCC","#D7DD46","#92ADFE"],
                borderColor: ["rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)", "rgba(255,0,0,0.0)"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [3,2,1,3,1,3,3,4]
    };
    legendOptionsTestingSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
            position: 'top'
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    // This provides layer gives us the dividing border lines.
    // The data values for this are all set to 1.0 and the background
    // color is transparent so that the colors from the content layer
    // can show through.
    ///
    // this layer is drawn last.
    overlayDataTestingSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [5,5,5,5,5,5,5,5],
                backgroundColor: [
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)",
                    "rgba(255,0,0,0.0)"
                ],
                borderWidth: 3,
                borderColor: [
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000",
                    "#000000"
                ]
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [3,2,1,3,1,3,3,4]
    };
    overlayOptionsTestingSecurityAudit = {
        scale: {
            display: false
        },
        legend: {
          display: false
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              var label = data.labels[tooltipItem.index] || '';
              return label + ": " + Math.round(data.true_values[tooltipItem.index]);
            }
          }
        }
    };


    // This layer provides the tick marks, it's drawn between the content and
    // the overlay.  The data values are all set to zero so that we get tick
    // marks all the way to the center, even where there's data
    //
    ticksDataTestingSecurityAudit = {
        datasets: [
            {
                label: "Score",
                data: [0,0,0,0,0,0,0,0],
            }
        ],
        labels: ["Audit/Compliance","Pen Testing","Hostile Environment","Code Scanning","Build Scanning","Separation of Duties - Automation","Separation of Duties - Separate Accounts","Cryptographic Signing"],
        true_values: [3,2,1,3,1,3,3,4]
    };
    ticksOptionsTestingSecurityAudit = {
        scale: {
            display: true,
            ticks: {
                gridLines: {
                    lineWidth: 3,
                    drawBorder: false,
                },

                beginAtZero: true,
                max: 1,
                callback: function (value, index, values) {
                    return "";
                }
            }
        },
        legend: {
            display: false
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    var label = data.labels[tooltipItem.index] || '';
                    return label + ": " + Math.round(data.true_values[tooltipItem.index]);
                }
            }
        }
    };

    new Chart(ctxTestingSecurityAudit, {
        data: dataTestingSecurityAudit,
        type: "polarArea",
        options: optionsTestingSecurityAudit
    });

    new Chart(overlayCtxTestingSecurityAudit, {
        data: overlayDataTestingSecurityAudit,
        type: "polarArea",
        options: overlayOptionsTestingSecurityAudit
    });

    new Chart(ticksCtxTestingSecurityAudit, {
        data: ticksDataTestingSecurityAudit,
        type: "polarArea",
        options: ticksOptionsTestingSecurityAudit
    });

    new Chart(legendCtxTestingSecurityAudit, {
        data: legendDataTestingSecurityAudit,
        type: "polarArea",
        options: legendOptionsTestingSecurityAudit
    });

</script>
    
    
    
    
    
    
    
    
    
<!-- </script> -->
</body>